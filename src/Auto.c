#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
<<<<<<< Updated upstream
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
=======
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
>>>>>>> Stashed changes
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR_Sensor,      sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          spinnerLeft,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          spinnerRight,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
<<<<<<< Updated upstream
#pragma config(Motor,  mtr_S1_C1_1,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     backRight,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     linearRight,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C2_1,    pullerLeft,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_2,    pullerRight,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_3,    doorFront,            tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    doorBack,             tServoStandard)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
=======
#pragma config(Motor,  mtr_S1_C1_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     linearRight,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRight,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C1_1,    doorBack,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_2,    doorFront,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_3,    pullerLeft,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    pullerRight,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
>>>>>>> Stashed changes
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Util.h"
#include "Motor.h"
#include "Auto.h"
#include "IR.h"

void initializeRobot()
{
    disableDiagnosticsDisplay();

    servoChangeRate[pullerLeft] = 3;
    servoChangeRate[pullerRight] = 3;

    nMotorEncoder[backRight] = 0;

    startTask(Start_IR);

    eraseDisplay();
    autoRoutine = selectAutoRoutine();

    return;
}

<<<<<<< Updated upstream
// TODO: All this crap
=======

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
>>>>>>> Stashed changes

// Red - Ramp
void  routineOne()
{
<<<<<<< Updated upstream
    eraseDisplay();
    nxtDisplayBigTextLine(0, "One");

    RetractGrabbers();
    servo[doorFront] = 255;
    servo[doorBack] = 255;
    Drive(68, 90);	// Drive off the ramp

		//if (FuzzyEquals(IR, 7, 1))
		//{

		//]\\}
=======
  eraseDisplay();
  nxtDisplayBigTextLine(0, "Three");

  Drive(70, 90);
>>>>>>> Stashed changes
};

// Red - Ground
void routineTwo()
{
    eraseDisplay();
    nxtDisplayBigTextLine(0, "Two");

    RetractGrabbers();
    Drive(12, 90);
};

// Blue - Ramp
void routineThree()
{
    eraseDisplay();
    nxtDisplayBigTextLine(0, "Three");

<<<<<<< Updated upstream
=======
  //RetractGrabbers();

    Drive(68, 90);  // Drive off the ramp
    wait1Msec(250);
    handleIR();

    if (rampEndPosOne || rampEndPosTwo)
    {
      Turn(-WHEEL_45_DEGREES * 1.4, 90);  // Turn away from the ramp
      wait1Msec(250);
      handleIR();

      if (rampEndTurnPosOne || rampEndTurnPosTwo)
      {
        Drive(-30, 90);  // Drive away from the ramp
        wait1Msec(250);
        handleIR();

        if (rampBackPosOne)
        {
          Turn(-WHEEL_45_DEGREES * 0.7, 90);  // Turn towards the pole
          wait1Msec(250);
          Drive(-32, 90);  // Knock down the pole
          wait1Msec(250);
          Turn(-WHEEL_45_DEGREES * 0.4, 90);  // Make sure it's down
          wait1Msec(250);
          Drive(20, 90);  // Drive away
          wait1Msec(250);
        }
      }
    }

    if (rampEndPosThree)
    {
   		Turn(-WHEEL_90_DEGREES, 90);
   	  wait1Msec(250);
   	  handleIR();

   	  if (rampEndTurnPosThree)
   	  {
   	  	Drive(-44, 90);
   	  	wait1Msec(250);
   	  	Turn(-WHEEL_45_DEGREES, 90);
   	  	wait1Msec(250);
   	  	Drive(12, 90);
   		}
    }
>>>>>>> Stashed changes
};

// Blue - Ground
void routineFour()
{
    while (1)
    {
        eraseDisplay();
        nxtDisplayBigTextLine(0, "Four");
    }
};

task main()
{
    initializeRobot();

    eraseDisplay();
    nxtDisplayBigTextLine(0, "Routine:");
    nxtDisplayBigTextLine(2, "%u", autoRoutine);

    waitForStart();

    switch(autoRoutine)
    {
        case AUTO_ROUTINE_ONE:
            routineOne();
            break;

        case AUTO_ROUTINE_TWO:
            routineTwo();
            break;

        case AUTO_ROUTINE_THREE:
            routineThree();
            break;

        case AUTO_ROUTINE_FOUR:
            routineFour();
            break;

        default:
            break;
    }
}
